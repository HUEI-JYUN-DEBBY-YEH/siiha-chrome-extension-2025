// src/logic/intensityGate.js
// Ë®äËôü‰æõÊáâÂô®ÔºàpluggableÔºâÔºöLocal Ë¶èÂâáÁÇ∫Âü∫Á§éÔºåËã•Áí∞Â¢ÉÂÖÅË®±ÂèØÂòóË©¶ Prompt API Ë£úÂº∑„ÄÇ
// - ‰∏çÂãï DOM„ÄÅ‰∏çÁ¢∞ storage„ÄÇ
// - Â∞çÂ§ñ‰∏ª‰ªãÈù¢ÔºödetectTone(text, { mode, env, timeoutMs })ÔºõscoreText() ‰ªç‰øùÁïô‰ΩúÂà•Âêç„ÄÇ
// - Êú¨Ê™îÂä†ÂÖ•ÔºöÂö¥Ê†ºÊ†ºÂºèÁ¥ÑÊùüÁöÑ prompt„ÄÅÈüåÊÄßËß£ÊûêÂô®„ÄÅÂö¥Ê†ºÈ©óË≠âËàáËßÄÊ∏¨Ê¨Ñ‰Ωç„ÄÇ
// - üß© Á∫åËÅäÈâ§Â≠êÔºöÊèê‰æõ„ÄåË∂ÖËºïÊëòË¶Å„ÄçËàá„ÄåÈóúÈçµË©û„ÄçÁ¥îÂáΩÂºèÔºà‰æõ SW ÁîüÊàêË™ûÂ¢ÉÊëòË¶ÅÔºâ„ÄÇ

const LEX = {
  high: [
    /suicid(e|al)|Ëá™ÊÆ∫|‰∏çÊÉ≥Ê¥ª|Ê¥ª‰∏ç‰∏ãÂéª|kill myself/i,
    /panic|ÊÅêÊÖå|Â¥©ÊΩ∞|Âèó‰∏ç‰∫Ü|ÁµïÊúõ/i,
    /die|Ê≠ª‰∫°|ÂéªÊ≠ª/i,
  ],
  mid: [
    /anxious|anxiety|ÁÑ¶ÊÖÆ|ÂøÉÊÇ∏|Â£ìÂäõ/i,
    /sad|Ê≤ÆÂñ™|‰ΩéËêΩ|Èõ£ÈÅé|Â§±Áú†/i,
    /tired|burn(ed)?\s?out|ÂÄ¶|Áñ≤ÊÜä/i,
  ],
  grounding: [/ÂëºÂê∏|breath|Ê∑±ÂëºÂê∏|ÂÜ∑Èùú|calm/i],
  // ÁîüÁêÜÁ∑öÁ¥¢ÔºàÁî®Êñº physio Ê®ôÁ±§Ëàá b3c1 ÂÅèÂ£ìÔºâ
  physio: [
    /ÂøÉË∑≥(?:Âø´|ÂæàÂø´)|ÂøÉÊÇ∏|ËÉ∏ÊÇ∂|Âñò|ÂëºÂê∏‰∏çÈ†Ü|ËÉÉÁ∏Æ|ÁôºÊäñ|ÊâãÊäñ|Âá∫Ê±ó|ÂÜíÊ±ó|È†≠Êöà|ËÉ∏Âè£Á∑ä/i,
    /\b(heart\s*racing|tight(\s*chest)?|short(ned)?\s*breath|stomach\s*knot|dizz(y|iness)|sweat(ing)?)\b/i
  ],  
  // ‰ΩøÁî®ËÄÖË¶Å„Äå‰ΩúÊ≥ï/ÂàÜÊûê/Âª∫Ë≠∞/ÂõûÈ•ã„Äç
  ask: [
    /\b(approach|approaches|suggestions?|advice|feedback|analy[sz]e|analysis)\b/i,
    /‰ΩúÊ≥ï|ÊñπÊ≥ï|ÂÅöÊ≥ï|Ê≠•È©ü|Âª∫Ë≠∞|ÊÑèË¶ã|ÂõûÈ•ã|ÂàÜÊûê|ÊÄéÈ∫ºÈù¢Â∞ç|ÊÄéÈ∫ºËôïÁêÜ|ÊÄéÈ∫ºÊ∫ùÈÄö/i
  ],  
  // üîé Light heuristics for locks & soft rejections
  // p1 = gate.p1
  p1: [
    /\b(stay (?:right )?here|just be here|sit with me|stay with me)\b/i,
    /\b(listen|just listen|hear me)\b(?!.*(plan|fix|solve))/i,
    /Âè™Ë¶ÅÈô™Êàë|Â∞±Èô™Êàë|Èô™ËëóÊàë|Âú®ÈÄôË£°Â∞±Â•Ω|ÁïôÂú®ÈÄôË£°|ÂÖàÈô™Êàë‰∏Ä‰∏ã/i
  ],
  // rj = sig.rj
  rj: [
    /\b(no advice|don'?t (try to )?fix|stop fixing|not helping|i don'?t want solutions?)\b/i,
    /‰∏çË¶Å(?:Áµ¶)?Âª∫Ë≠∞|Âà•(?:ÂÜç)?ÂàÜÊûê|‰∏çË¶ÅËß£Ê±∫|ÂÖà‰∏çË¶Å(?:Ë®éË´ñ|ËôïÁêÜ)|Ê≤íÂú®ËÅΩ/i
  ]
};

// ‚Äî‚Äî ËºîÂä©ÔºöÁÑ¶ÊÖÆÁ∑öÁöÑÁâáË™û/ÂûãÊÖãÁ∑öÁ¥¢ÔºàÊò†Â∞ÑÊàê anxious_cueÔºâ
function __anxiousHeuristics(text) {
  const s = String(text || "").toLowerCase();
  if (!s) return false;
  // ÂêåÁæ©Ë©ûÔºèËøëÁæ©Ë©ûÔºàÂøÉÁêÜË™ûÊÑèÔºâ
  const lexHit =
    /\b(anxious|anxiety|worried|worry|nervous|stressed|overwhelmed|uneasy|jittery|scared|afraid|fear|dread|panic)\b/.test(s) ||
    /(ÊìîÂøÉ|Á∑äÂºµ|ÁÑ¶Ë∫Å|ÁÑ¶ÊÖÆ|ÁôºÊÖå|ÂøÉÊÖå|ÂÆ≥ÊÄï|ÊÄïÂ§±Êéß|Â£ìÂäõÂ•ΩÂ§ß|Â•ΩÁÑ¶|ÂæàÊÖå)/.test(s) ||
    /(ËÖ¶Ë¢ãÂÅú‰∏ç‰∏ã‰æÜ|Áù°‰∏çËëó|ËΩâÂÄã‰∏çÂÅú|‰∏ÄÁõ¥Âú®ÊÉ≥|ÊÉ≥ÂæàÂ§ö)/.test(s) ||
    /\bwhat\s+if\b/.test(s);
  // ÂûãÊÖãÁ∑öÁ¥¢ÔºöÂïèËôüÂØÜÂ∫¶‚Üë„ÄÅÁü≠Âè•ÈÄ£Áôº„ÄÅÊú™‰æÜÂêë„ÄÅÂê¶ÂÆöÂèçË¶Ü
  const qm = (s.match(/\?/g) || []).length;
  const sentences = s.split(/[.!?„ÄÇÔºÅÔºüÔºõ;]+/).filter(x => x.trim().length);
  const shortBursts = sentences.filter(x => x.trim().length <= 25).length >= 3;
  const futurey = /(ÊòéÂ§©|‰∏ãÈÄ±|‰∏ãÂë®|Â¶ÇÊûú|Ëê¨‰∏Ä|\bif\b|\btomorrow\b|\bnext (week|month)\b)/.test(s);
  const negRepeat = /(‰∏çË°å|‰∏çÂ§†|‰∏çÊúÉ|Ê≤íËæ¶Ê≥ï|no way|can'?t|won'?t)/i.test(s) && (s.match(/‰∏ç|no|n't/gi) || []).length >= 3;
  return lexHit || qm >= 2 || shortBursts || futurey || negRepeat;
}

// --- Local Ë¶èÂâá‰æõÊáâÂô®ÔºàÂéüÊú¨ÈÇèËºØÂ∞ÅË£ùÔºâ ---
function localRulesProvider(inputText) {
  const text = (inputText || "").toString().trim();
  if (!text) {
    return {
      level: "low",
      score: 0,
      tags: ["empty"],
      signals: {},
      meta: { provider: "local", fallback: false, summaryHint: "", keywords: [] }
    };
  }

  let score = 0;
  const hits = { high: [], mid: [], grounding: [], physio: [], p1: [], rj: [], ask: [] };

  LEX.high.forEach((re) => { if (re.test(text)) hits.high.push(re.source); });
  LEX.mid.forEach((re)  => { if (re.test(text)) hits.mid.push(re.source); });
  LEX.grounding.forEach((re) => { if (re.test(text)) hits.grounding.push(re.source); });
  LEX.physio.forEach((re) => { if (re.test(text)) hits.physio.push(re.source); });
  (LEX.ask||[]).forEach((re) => { if (re.test(text)) hits.ask.push(re.source); });  
  LEX.p1.forEach((re) => { if (re.test(text)) hits.p1.push(re.source); });
  LEX.rj.forEach((re) => { if (re.test(text)) hits.rj.push(re.source); });

  // Á∞°ÂñÆÊâìÂàÜÔºöÂëΩ‰∏≠ high/mid ÁñäÂä†ÔºõÈï∑Â∫¶ËàáÂòÜË©ûËºïÂæÆÂä†Ê¨ä
  score += hits.high.length * 2.0;
  score += hits.mid.length * 1.0;
  // ÁÑ¶ÊÖÆÁ∑öÁ¥¢‰∏ãÈôêÂæÆÊèêÂàÜÔºåÈÅøÂÖçË¢´Âà§Â§™‰ΩéÂºµ
  if (__anxiousHeuristics(text)) score += 0.5;

  const len = Math.min(200, text.length);
  if (len > 40) score += 0.3;
  // üß© Ê®ôÈªûÂºµÂäõÂº∑ÂåñÔºàÂ§öÈáçÊÑüÂòÜÔºèÁñëÂïèÊèêÂçáÊ¨äÈáçÔºâ
  if (/[!?]{2,}/.test(text)) score += 0.4;
  if (/[!?]{4,}/.test(text)) score += 2.2; // Ê•µÁ´ØÊ®ôÈªûÁõ¥Êé•ÊèêÂçáËá≥ mid ÂçÄÈñì

  // ÈôêÂà∂Âú® 0~5
  score = Math.max(0, Math.min(5, Number(score.toFixed(2))));

  let level = "low";
  if (score >= 3.6) level = "high";
  else if (score >= 2.1) level = "mid";

  const tags = [];
  if (hits.high.length) tags.push("crisis_lang");
  if (hits.mid.length)  tags.push("distress_lang");
  if (hits.grounding.length) tags.push("grounding_cue");
  if (hits.physio.length) tags.push("physio");
  if (hits.ask.length) tags.push("ask_approach");
  // Ëã•ÂêåÊôÇ„ÄåË¶ÅÊñπÊ≥ï„Äç‰∏îÂ∏∂ÊúâË∫´È´î/grounding Á∑öÁ¥¢ÔºåË£ú‰∏ÄÂÄãË™ûÊÑèÊõ¥Á™ÑÁöÑÊèêÁ§∫Ôºà‰æõÂ∞á‰æÜËßÄÊ∏¨/Áñä‰ª£Ôºõ‰∏çÂΩ±ÈüøÊó¢ÊúâË∑ØÁî±Ôºâ
  if (hits.ask.length && (hits.grounding.length || hits.physio.length)) {
    tags.push("ask_grounding");
  }
  // Áµ±‰∏ÄÊò†Â∞ÑÔºöÁÑ¶ÊÖÆÁ∑öÔºàÊÉÖÁ∑í/ÁâáË™û/ÂûãÊÖã‰ªª‰∏ÄÂëΩ‰∏≠Ôºâ‚Üí anxious_cue
  if (__anxiousHeuristics(text)) tags.push("anxious_cue");
  // ‰ª• SW Ê±∫Á≠ñÁÇ∫‰∏ªÔºõÊ≠§Â±§ÂÉÖÂÖúÂ∫ïÂú∞Ê®ôË®òÁü≠Á¢º tags
  if (hits.p1.length) tags.push("p1");   // gate.p1
  if (hits.rj.length) tags.push("rj");   // sig.rj

  return {
    level,
    score,
    tags,
    signals: hits,
    meta: { provider: "local", fallback: false, summaryHint: makeUltraBrief(text), keywords: extractSummaryKeywords(text) }
  };
}

// --- Prompt API ‰æõÊáâÂô®ÔºàÂèØÁî®ÊôÇÂòóË©¶ÔºõÂ§±ÊïóÊôÇÂõûÈÄÄ localÔºâ ---
// ÂÜ∑ÂïüÂãïËºÉÊÖ¢ÔºöÁ¨¨‰∏ÄÊ¨°Áµ¶ÂØ¨È¨Ü timeoutÔºåÊàêÂäüÂæåÁ∏ÆÁü≠„ÄÇ
let __LM_WARMED = false;
// ÂÖßÈÉ®ÔºöÈüåÊÄßËß£ÊûêÔºàÊîØÊè¥ÂéªÈô§ code fence / ÂèñÁ¨¨‰∏ÄÂÄãÂπ≥Ë°°Â§ßÊã¨Ëôü / ËºïÂ∫¶‰øÆÂæ©Ôºâ
function __robustParseJSON(raw) {
  if (raw == null) return { ok:false, reason:"empty" };
  let s = String(raw).trim();
  // Âø´Ë∑ØÂæëÔºöÁõ¥Êé• parse
  try { return { ok:true, value: JSON.parse(s), stage:"raw" }; } catch {}
  // code fence ÊäΩÂèñ
  if (/^```/m.test(s)) {
    const m = s.match(/```(?:json)?\s*([\s\S]*?)```/i);
    if (m && m[1]) {
      const t = m[1].trim();
      try { return { ok:true, value: JSON.parse(t), stage:"fence" }; } catch {}
      s = t; // ÁπºÁ∫åÂæåÁ∫åÊ≠•È©ü
    }
  }
  // ÂéªÈô§Â∏∏Ë¶ãÂâçÁ∂¥Ôºàjson:, JSON:, Output: Á≠âÔºâ
  s = s.replace(/^\s*(?:json\s*:|output\s*:)\s*/i, "");
  // ÂèñÁ¨¨‰∏ÄÂÄãÂπ≥Ë°°Â§ßÊã¨ËôüÂçÄÊÆµ
  const i = s.indexOf("{");
  if (i >= 0) {
    let depth = 0, j = -1;
    for (let k = i; k < s.length; k++) {
      const ch = s[k];
      if (ch === "{") depth++;
      if (ch === "}") { depth--; if (depth === 0) { j = k; break; } }
    }
    if (j > i) {
      const seg = s.slice(i, j + 1);
      try { return { ok:true, value: JSON.parse(seg), stage:"balanced" }; } catch {}
    }
  }
  // ËºïÂ∫¶‰øÆÂæ©ÔºöÂñÆÂºïËôüËΩâÈõôÂºïËôüÔºàÂè™Âú®Ê≤íÊúâÈõôÂºïËôüÊôÇÂòóË©¶Ôºâ„ÄÅÁßªÈô§Â∞æÈÄóËôü
  let relaxed = s;
  if (/\'/.test(relaxed) && !/\".*\'/.test(relaxed)) {
    relaxed = relaxed.replace(/'/g, "\"");
  }
  relaxed = relaxed.replace(/,\s*([}\]])/g, "$1");
  try { return { ok:true, value: JSON.parse(relaxed), stage:"relaxed" }; } catch {}
  return { ok:false, reason:"parse_failed" };
}

// ÂÖßÈÉ®ÔºöÈ©óË≠âËàáË¶èÁØÑÂåñ
function __validateToneJSON(obj) {
  const out = { level:"low", tags:[], crisis:false };
  if (obj && typeof obj === "object") {
    const map = { low:"low", mid:"mid", medium:"mid", high:"high" };
    const lv = String(obj.level ?? "").toLowerCase();
    out.level = map[lv] || "low";
    if (Array.isArray(obj.tags)) {
      out.tags = Array.from(new Set(obj.tags.map(x => String(x)).filter(Boolean))).slice(0, 12);
    }
    out.crisis = Boolean(obj.crisis);
  }
  return out;
}

async function promptApiProvider(inputText, { timeoutMs } = {}) {
  // 1) ÊäìÂëΩÂêçÁ©∫ÈñìÔºàLanguageModel ÂÑ™ÂÖàÔºå‰øùÁïô ai.languageModel Áõ∏ÂÆπÔºâ
  const LM = globalThis.LanguageModel || globalThis.ai?.languageModel;
  if (!LM) throw new Error("prompt_api_unavailable");

  // 2) ÂèØÁî®ÊÄßÊ™¢Êü•Ôºö‰∏çÊòØ available Â∞±‰∏çË¶ÅÁ°¨Á≠âÔºåÁõ¥Êé•ÂõûÈÄÄ
  try {
    const a = typeof LM.availability === "function" ? await LM.availability() : "available";
    var __LM_AVAIL = String(a).toLowerCase();
    if (__LM_AVAIL !== "available") throw new Error("prompt_api_not_ready:" + __LM_AVAIL);
  } catch {
    throw new Error("prompt_api_not_ready");
  }

  // 3) ÈÄæÊôÇÁ≠ñÁï•ÔºöÂÜ∑ÂïüÂãïËºÉÈï∑ÔºàÈ†êË®≠ 6000msÔºâÔºåÊöñÊ©üÂæå 2000msÔºõÂëºÂè´Á´ØÂèØË¶ÜÂØ´
  const coldDefault = 6000;
  const warmDefault = 2000;
  const effTimeout = Number(timeoutMs ?? (__LM_WARMED ? warmDefault : coldDefault));

  // 4) Âª∫Á´ã sessionÔºàÁî® Promise.race ÊéßÂà∂ÈÄæÊôÇÔºõÈÅøÂÖç‰æùË≥¥ AbortController.signalÔºâ
  const __t0 = Date.now();
  const session = await Promise.race([
    // ‰ΩéÊ∫´ + ‰Ωé topKÔºåÈôç‰ΩéÂ§öË©±
    LM.create({ temperature: 0.2, topK: 1 }),
    new Promise((_, rej) => setTimeout(() => rej(new Error("prompt_api_timeout_create")), effTimeout))
  ]);

  try {
    const __tCreate = Date.now() - __t0;
    // Âö¥Ê†ºÊ†ºÂºèÁ¥ÑÊùü + Ê≠£Âèç‰æã + fallback Êåá‰ª§
    const prompt = [
      "You are a strict classifier.",
      "Return ONLY a single JSON object. No code fences, no markdown, no explanations.",
      "Schema: { level: 'low|mid|high', tags: string[], crisis: boolean }",
      "If unsure, return: {\"level\":\"low\",\"tags\":[],\"crisis\":false}",
      "",
      "Good example:",
      "{\"level\":\"mid\",\"tags\":[\"distress_lang\"],\"crisis\":false}",
      "Bad examples (do NOT do this):",
      "```json {\"level\":\"mid\"} ```",
      "Output: {\"level\":\"mid\"}",
      "",
      "Text:",
      JSON.stringify(String(inputText || "").slice(0, 800))
    ].join("\n");

    const __t1 = Date.now();
    const raw = await Promise.race([
      session.prompt(prompt),
      new Promise((_, rej) => setTimeout(() => rej(new Error("prompt_api_timeout_infer")), effTimeout))
    ]);
    const __tInfer = Date.now() - __t1;

    // ÈüåÊÄßËß£Êûê + È©óË≠â
    const parsedTry = __robustParseJSON(raw);
    if (!parsedTry.ok) throw new Error("prompt_api_bad_response");
    const normalized = __validateToneJSON(parsedTry.value);
    if (!normalized || !normalized.level) throw new Error("prompt_api_bad_response");

    // ‰∏ÄÊ¨°ÊàêÂäüÂæåË¶ñÁÇ∫ÊöñÊ©üÂÆåÊàê
    __LM_WARMED = true;

    // Ë¶èÁØÑÂåñËº∏Âá∫
    const level = normalized.level;
    const tags = normalized.tags.slice();
    if (normalized.crisis === true && !tags.includes("crisis_lang")) tags.push("crisis_lang");

    // ‰ª•Ê•µÂ∞è heuristics Âêà‰ΩµÊú¨Âú∞ hitsÔºàÈÅøÂÖçÈÅéÂ∫¶‰æùË≥¥Ôºâ
    const local = localRulesProvider(inputText);
  // ================================================
  // üß© ‰øÆ‰∫åÔºöÂç±Ê©üÈôçË∫ÅÔºàÈõôÂÅ¥Á¢∫Ë™çÊâçÂçáÁ¥öÔºâ
  // ================================================
  const localHighHit = local.tags.includes("crisis_lang") || (local.signals.high?.length > 0);
  let mergedTags = Array.from(new Set([...local.tags, ...tags]));

  // ÈõôÂÅ¥ÂêåÊôÇÂëΩ‰∏≠ÊâçÂçáÁ¥öÁÇ∫Âç±Ê©ü
  let crisis = false;
  if (tags.includes("crisis_lang") && localHighHit) {
    crisis = true;
    if (!mergedTags.includes("crisis_lang")) mergedTags.push("crisis_lang");
  } else {
    // ÂñÆÂÅ¥ÂëΩ‰∏≠ÂâáÈôçË∫ÅÁÇ∫ distress_lang
    mergedTags = mergedTags.filter(t => t !== "crisis_lang");
    if (!mergedTags.includes("distress_lang")) mergedTags.push("distress_lang");
  }

  // ================================================
  // üß© ‰øÆ‰∏âÔºöMid ‰∏ãÈôêÔºàÁÑ¶ÊÖÆ/Â£ìÂäõ/Áù°‰∏çÂ•Ω ‚Üí ÊúÄ‰Ωé midÔºâ
  // ================================================
  let mergedLevel = "low";
  if (crisis) {
    mergedLevel = "high";
  } else if (level === "mid" || local.level === "mid") {
    mergedLevel = "mid";
  } else {
    const txt = String(inputText || "").toLowerCase();
    if (/(anxiety|anxious|stress|Â£ìÂäõ|ÁÑ¶ÊÖÆ|Áù°‰∏çÂ•Ω)/i.test(txt)) {
      mergedLevel = "mid";
    } else {
      mergedLevel = "low";
    }
  }

  // ü©π Ë£úÈáòÔºöÂú® prompt Ë∑ØÂæë‰πüÂ•óÁî®Êú¨Âú∞ÁöÑ p1/rj ËºïË¶èÂâá
  const textL = String(inputText || "");
  const p1Hit = LEX.p1.some(re => re.test(textL));
  const rjHit = LEX.rj.some(re => re.test(textL));
  if (p1Hit && !mergedTags.includes("p1")) mergedTags.push("p1");
  if (rjHit && !mergedTags.includes("rj")) mergedTags.push("rj");
  // ÁÑ¶ÊÖÆËàáÁîüÁêÜÔºöËàá local Â∞çÈΩäÔºåË£ú‰∏ä anxious_cue / physio
  if (__anxiousHeuristics(textL) && !mergedTags.includes("anxious_cue")) mergedTags.push("anxious_cue");
  if (LEX.physio.some(re => re.test(textL)) && !mergedTags.includes("physio")) mergedTags.push("physio");

  return {
    level: mergedLevel,
    score: local.score,
    tags: Array.from(new Set([
      ...mergedTags,
      ...((local.signals?.ask?.length || 0) ? ["ask_approach"] : [])
    ])),
    signals: { prompt: normalized, local: local.signals },
    meta: {
      provider: "prompt",
      fallback: false,
      // ‰æõÁ∫åËÅäË™ûÂ¢É‰ΩøÁî®Ôºà‰∏çÂ≠òÂÖ®ÊñáÔºâÔºö
      summaryHint: makeUltraBrief(String(inputText || "")),
      keywords: extractSummaryKeywords(String(inputText || "")),      
      debug: {
        lmAvail: __LM_AVAIL || "unknown",
        usedTimeoutMs: effTimeout,
        warmedBefore: __LM_WARMED,
        t: {
          createMs: __tCreate,
          inferMs: __tInfer,
          totalMs: (Date.now() - __t0)
        },
        rawPreview: String(raw).slice(0, 200),
       parseStage: parsedTry.stage || "unknown"
      }
    }
  };
  } finally {
    try { session?.destroy?.(); } catch {}
  }
}

/**
 * Â∞çÂ§ñ‰∏ª‰ªãÈù¢ÔºöËá™ÂãïÊàñÊåáÂÆö providerÔºå‰∏¶ÂÖ∑ÂÇôÈÄæÊôÇ/ÂõûÈÄÄ„ÄÇ
 * @param {string} inputText
 * @param {{mode?: "auto"|"local"|"prompt", env?: any, timeoutMs?: number}} opts
 */
export async function detectTone(inputText, opts = {}) {
  const mode = opts.mode || "auto";
  if (mode === "local") return localRulesProvider(inputText);
  if (mode === "prompt") {
    try {
      return await promptApiProvider(inputText, { timeoutMs: opts.timeoutMs });
    } catch (e) {
      const r = localRulesProvider(inputText);
      r.meta.fallback = true;
      // ÈôÑÂ∏∂ÈåØË™§ÂéüÂõ†ËàáÈöéÊÆµÔºåÊñπ‰æøÈô§ÈåØ
      try {
        const msg = String(e && (e.message || e));
        r.meta.error = msg;
        if (/timeout_create/i.test(msg)) r.meta.errorStage = "create";
        else if (/timeout_infer/i.test(msg)) r.meta.errorStage = "infer";
        else if (/not_ready/i.test(msg)) r.meta.errorStage = "availability";
        else if (/bad_response/i.test(msg)) r.meta.errorStage = "parse";        
      } catch {}
      return r;
    }
  }
  // autoÔºö‰æù env.canUsePromptAPI Ê±∫ÂÆö
  if (opts.env?.canUsePromptAPI) {
    try {
      return await promptApiProvider(inputText, { timeoutMs: opts.timeoutMs });
    } catch (e) {
      const r = localRulesProvider(inputText);
      r.meta.fallback = true;
      try {
        const msg = String(e && (e.message || e));
        r.meta.error = msg;
        if (/timeout_create/i.test(msg)) r.meta.errorStage = "create";
        else if (/timeout_infer/i.test(msg)) r.meta.errorStage = "infer";
        else if (/not_ready/i.test(msg)) r.meta.errorStage = "availability";
        else if (/bad_response/i.test(msg)) r.meta.errorStage = "parse";
      } catch {}
      return r;
    }
  }
  return localRulesProvider(inputText);
}

// ÂÖºÂÆπËàäÊé•Âè£Ôºö‰øùÁïô scoreText() ÂêçÁ®±ÔºåÁ≠âÂêå detectTone()
export function scoreText(input) {
  return localRulesProvider(input);
}

// =============================
// üß© Á∫åËÅäÈâ§Â≠êÔºàÁ¥îÂáΩÂºèÔºõ‰∏çËß∏Â∫´Ôºâ
// =============================
/**
* ÂèñÁ¨¨‰∏ÄÂè•/‰∏ªË¶ÅÂ≠êÂè•ÔºåÂéªÈô§Â§öÈ§òÁ©∫ÁôΩËàáÂåÖÂºïËôüÔºåÈôêÂà∂Èï∑Â∫¶„ÄÇ
 * Ëàá SW ÁâàÊú¨ÈÇèËºØÂ∞çÈΩäÔºõÊ≠§ËôïÊö¥Èú≤Áµ¶ÂëºÂè´Á´ØÁï∂‰Ωú„ÄåÊëòË¶ÅÂª∫Ë≠∞„Äç„ÄÇ
 */
export function makeUltraBrief(s = "", max = 80) {
  const t = String(s || "").replace(/\s+/g, " ").trim();
  if (!t) return "";
  const first = t.split(/(?<=[„ÄÇÔºÅÔºü!?ÔΩ°]|\.|\?|!|;|Ôºõ)/)[0] || t;
  const cleaned = first.replace(/^["'‚Äú‚Äù‚Äò‚Äô]+|["'‚Äú‚Äù‚Äò‚Äô]+$/g, "").trim();
  return cleaned.length > max ? cleaned.slice(0, max - 1) + "‚Ä¶" : cleaned;
}

 /**
 * Ë∂ÖËºïÈáèÈóúÈçµË©ûÊäΩÂèñÔºàËã±/‰∏≠Á≤óÁï•ÁâàÔºõÁÑ°Â§ñ‰æùË≥¥Ôºâ
 * - Ëã±ÊñáÔºöÈï∑Â∫¶‚â•3 ÁöÑÂñÆÂ≠óÔºåÈ†ªÊ¨°ÊéíÂ∫è
 * - ‰∏≠ÊñáÔºöÂéªÈô§Â∏∏Ë¶ãÂä©Ë©û/ËôõË©ûÁöÑÂñÆÂ≠óÔºåÈ†ªÊ¨°ÊéíÂ∫èÔºà‰øùÂÆàÔºõÈÅøÂÖçÊ¥©Èú≤ÂÖ®ÊñáÔºâ
 * ÂõûÂÇ≥‰∏çË∂ÖÈÅé max ÂÄãÂéªÈáçÈóúÈçµË©ûÔºàÂ∞èÂØ´/ÂéüÊ®£Ê∑∑ÂêàÔºåÂÉÖ‰æõ UI/ÊëòË¶ÅÊèêÁ§∫Ôºâ
 */
export function extractSummaryKeywords(text = "", max = 5) {
  const s = String(text || "").trim();
  if (!s) return [];
  const en = (s.match(/\b[a-zA-Z]{3,}\b/g) || []).map(w => w.toLowerCase());
  const zhChars = (s.match(/[\u4e00-\u9fff]/g) || []);

  const EN_STOP = new Set([
    "the","and","for","with","that","this","have","from","your","about",
    "just","really","very","much","been","into","will","what","when","where",
    "how","why","like","feel","feelings","today","these","those","over","under"
  ]);
  const ZH_STOP = new Set(["Êàë","‰Ω†","‰ªñ","Â•π","ÂÆÉ","ÂÄë","ÁöÑ","‰∫Ü","Âë¢","Âóé","Âú®","ÊòØ","Âæà","‰∏ç","Ê≤í","ÁÑ°","Ëàá","Âíå","Âèä","Â∞±","‰πü","ËÄå","ÈÇÑ","Âèà","ÈÉΩ","Ë¢´","Êää","Ë¶Å","ÊúÉ","ÂÉè","ËÆì","Ëëó"]);

  const freq = new Map();
  for (const w of en) {
    if (EN_STOP.has(w)) continue;
    freq.set(w, (freq.get(w) || 0) + 1);
  }
  for (const ch of zhChars) {
    if (ZH_STOP.has(ch)) continue;
    // ÈÅéÊøæÊï∏Â≠ó/Ê®ôÈªû
    if (!/[\u4e00-\u9fff]/.test(ch)) continue;
    freq.set(ch, (freq.get(ch) || 0) + 1);
  }
  const ranked = [...freq.entries()].sort((a,b) => b[1]-a[1]).map(x => x[0]);
  return ranked.slice(0, Math.max(1, Math.min(12, Number(max)||5)));
}